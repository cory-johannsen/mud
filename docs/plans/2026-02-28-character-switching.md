# Character Switching Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add an in-game `switch` command that saves the current character, removes them from the world, and returns the player to the character selection screen without disconnecting their Telnet session.

**Architecture:** The `switch` command follows CMD-1 through CMD-7 exactly. Server-side it is identical to `handleQuit`. The frontend's `gameBridge` returns a sentinel `errSwitchCharacter`; `characterFlow` catches it and loops back to character selection instead of ending the session. Duplicate character protection is enforced by the server's existing `AddPlayer` uniqueness check.

**Tech Stack:** Go, gRPC/protobuf, `pgregory.net/rapid` for property tests, `mise run go` for all Go commands.

---

### Task 1: Register the switch command (CMD-1, CMD-2, CMD-3)

**Files:**
- Modify: `internal/game/command/commands.go`
- Create: `internal/game/command/switch.go`
- Test: `internal/game/command/switch_test.go`

**Background:** Every command needs a `Handler<Name>` constant, a `BuiltinCommands()` entry, and a `Handle<Name>` function. Read `internal/game/command/quit.go` and `internal/game/command/commands.go` for the exact patterns to follow.

**Step 1: Write the failing test**

Create `internal/game/command/switch_test.go`:

```go
package command_test

import (
	"testing"

	"pgregory.net/rapid"

	"github.com/cory-johannsen/mud/internal/game/command"
)

func TestHandleSwitch_ReturnsEmptyString(t *testing.T) {
	result := command.HandleSwitch([]string{})
	if result != "" {
		t.Errorf("HandleSwitch() = %q, want empty string", result)
	}
}

func TestProperty_HandleSwitch_AlwaysEmptyString(t *testing.T) {
	rapid.Check(t, func(t *rapid.T) {
		args := rapid.SliceOf(rapid.String()).Draw(t, "args")
		result := command.HandleSwitch(args)
		if result != "" {
			t.Fatalf("HandleSwitch(%v) = %q, want empty string", args, result)
		}
	})
}
```

**Step 2: Run test to verify it fails**

```bash
cd /home/cjohannsen/src/mud && mise run go test ./internal/game/command/... -run "TestHandleSwitch|TestProperty_HandleSwitch" -v 2>&1 | head -20
```

Expected: FAIL — `command.HandleSwitch` undefined

**Step 3: Add HandlerSwitch constant and BuiltinCommands entry**

In `internal/game/command/commands.go`, add after `HandlerQuit`:

```go
HandlerSwitch = "switch"
```

In `BuiltinCommands()`, add an entry (place it near HandlerQuit):

```go
{
    Handler:     HandlerSwitch,
    Name:        "switch",
    Usage:       "switch",
    Description: "Switch to a different character without disconnecting.",
    MinRole:     RolePlayer,
},
```

**Step 4: Create `internal/game/command/switch.go`**

Read `internal/game/command/quit.go` for the exact file structure, then create:

```go
package command

// HandleSwitch handles the switch command.
// Switching is a frontend-driven operation; the server receives a SwitchCharacterRequest.
// This function exists to satisfy the command registry; it returns an empty string.
//
// Precondition: args may be nil or empty.
// Postcondition: Returns an empty string.
func HandleSwitch(args []string) string {
	return ""
}
```

**Step 5: Run tests to verify they pass**

```bash
cd /home/cjohannsen/src/mud && mise run go test ./internal/game/command/... -v 2>&1 | tail -15
```

Expected: all PASS

**Step 6: Commit**

```bash
cd /home/cjohannsen/src/mud && git add internal/game/command/commands.go internal/game/command/switch.go internal/game/command/switch_test.go
git commit -m "feat: register switch command (CMD-1, CMD-2, CMD-3)"
```

---

### Task 2: Add SwitchCharacterRequest proto message (CMD-4)

**Files:**
- Modify: `api/proto/game/v1/game.proto`
- Modify: `internal/gameserver/gamev1/game.pb.go` (regenerated by make proto)

**Background:** The proto file is at `api/proto/game/v1/game.proto`. The generated Go bindings used by the gameserver are at `internal/gameserver/gamev1/game.pb.go`. Run `make proto` to regenerate — this updates both files. Always commit the regenerated `.pb.go`.

Look at how `QuitRequest` is defined in the proto and added to `ClientMessage` oneof to follow the exact same pattern.

**Step 1: Add the proto message and oneof entry**

In `api/proto/game/v1/game.proto`:

Find `QuitRequest` (it will be an empty message like `message QuitRequest {}`). Add immediately after it:

```proto
// SwitchCharacterRequest asks the server to save and remove the current character
// so the player can select a different character without disconnecting.
message SwitchCharacterRequest {}
```

Find the `ClientMessage` oneof and the line for `quit`. The existing entries are numbered up to 29. Add after the `quit` entry (check the current highest field number and use next):

```proto
SwitchCharacterRequest switch_character = 30;
```

**Step 2: Regenerate**

```bash
cd /home/cjohannsen/src/mud && make proto
```

Expected: no errors, `internal/gameserver/gamev1/game.pb.go` is updated.

**Step 3: Verify the generated code compiles**

```bash
cd /home/cjohannsen/src/mud && mise run go build ./... 2>&1
```

Expected: no output (success)

**Step 4: Commit**

```bash
cd /home/cjohannsen/src/mud && git add api/proto/game/v1/game.proto internal/gameserver/gamev1/game.pb.go
git commit -m "feat: add SwitchCharacterRequest proto message (CMD-4)"
```

---

### Task 3: Add server handler handleSwitch (CMD-6)

**Files:**
- Modify: `internal/gameserver/grpc_service.go`
- Test: `internal/gameserver/grpc_service_switch_test.go` (new)

**Background:** Read `handleQuit` in `internal/gameserver/grpc_service.go` (~line 542). `handleSwitch` is functionally identical — it returns `errQuit` with a "switching characters" reason. The `defer s.cleanupPlayer(uid, username)` at the top of `Session()` handles all persistence automatically when `errQuit` causes the stream to end.

Also read the dispatch type switch in `commandLoop` (~line 259) to understand where to wire in the new case.

**Step 1: Write the failing test**

Create `internal/gameserver/grpc_service_switch_test.go` (package `gameserver`):

```go
package gameserver

import (
	"testing"

	gamev1 "github.com/cory-johannsen/mud/internal/gameserver/gamev1"
	"github.com/cory-johannsen/mud/internal/game/session"
	"pgregory.net/rapid"
)

func TestHandleSwitch_ReturnsDisconnectedWithSwitchReason(t *testing.T) {
	mgr := session.NewManager()
	_, _ = mgr.AddPlayer("uid1", "user1", "Hero", 1, "room1", 10, "player", "the Northeast", "Gunner", 3)
	s := &GameServiceServer{sessions: mgr}

	result, err := s.handleSwitch("uid1")
	if err != errQuit {
		t.Fatalf("expected errQuit, got %v", err)
	}
	d := result.GetDisconnected()
	if d == nil {
		t.Fatal("expected Disconnected payload")
	}
	if d.Reason == "" {
		t.Error("Reason must be non-empty")
	}
}

func TestHandleSwitch_UnknownUID_StillReturnsDisconnected(t *testing.T) {
	mgr := session.NewManager()
	s := &GameServiceServer{sessions: mgr}

	result, err := s.handleSwitch("nobody")
	if err != errQuit {
		t.Fatalf("expected errQuit, got %v", err)
	}
	if result.GetDisconnected() == nil {
		t.Fatal("expected Disconnected payload")
	}
}

func TestProperty_HandleSwitch_AlwaysReturnsErrQuit(t *testing.T) {
	rapid.Check(t, func(t *rapid.T) {
		mgr := session.NewManager()
		uid := rapid.StringMatching(`[a-z0-9]+`).Draw(t, "uid")
		charName := rapid.StringMatching(`[A-Za-z]+`).Draw(t, "charName")
		_, _ = mgr.AddPlayer(uid, "user", charName, 1, "room1", 10, "player", "the Northeast", "Gunner", 1)
		s := &GameServiceServer{sessions: mgr}

		_, err := s.handleSwitch(uid)
		if err != errQuit {
			t.Fatalf("handleSwitch must return errQuit, got %v", err)
		}
	})
}
```

**Step 2: Run test to verify it fails**

```bash
cd /home/cjohannsen/src/mud && mise run go test ./internal/gameserver/... -run "TestHandleSwitch|TestProperty_HandleSwitch" -v 2>&1 | head -20
```

Expected: FAIL — `handleSwitch` undefined

**Step 3: Implement handleSwitch and wire into dispatch**

In `internal/gameserver/grpc_service.go`, add after `handleQuit`:

```go
// handleSwitch saves the current player's state and signals a clean character switch.
// The behaviour is identical to handleQuit: errQuit causes the Session goroutine to
// call cleanupPlayer via defer, persisting all state before the stream closes.
//
// Precondition: uid must be non-empty.
// Postcondition: Returns a Disconnected event with errQuit so the session terminates cleanly.
func (s *GameServiceServer) handleSwitch(uid string) (*gamev1.ServerEvent, error) {
	sess, _ := s.sessions.GetPlayer(uid)
	reason := "Switching characters"
	if sess != nil {
		reason = fmt.Sprintf("%s is switching characters", sess.CharName)
	}
	return &gamev1.ServerEvent{
		Payload: &gamev1.ServerEvent_Disconnected{
			Disconnected: &gamev1.Disconnected{Reason: reason},
		},
	}, errQuit
}
```

In the dispatch type switch inside `commandLoop`, add after the `*gamev1.ClientMessage_Quit` case:

```go
case *gamev1.ClientMessage_SwitchCharacter:
	return s.handleSwitch(uid)
```

**Step 4: Run tests to verify they pass**

```bash
cd /home/cjohannsen/src/mud && mise run go test ./internal/gameserver/... -v 2>&1 | tail -15
```

Expected: all PASS

**Step 5: Commit**

```bash
cd /home/cjohannsen/src/mud && git add internal/gameserver/grpc_service.go internal/gameserver/grpc_service_switch_test.go
git commit -m "feat: add handleSwitch server handler (CMD-6)"
```

---

### Task 4: Add bridgeSwitch frontend handler and errSwitchCharacter sentinel (CMD-5)

**Files:**
- Modify: `internal/frontend/handlers/bridge_handlers.go`
- Modify: `internal/frontend/handlers/game_bridge.go`
- Test: `internal/frontend/handlers/game_bridge_dispatch_test.go` (existing — `TestAllCommandHandlersAreWired` must pass)

**Background:** Read `internal/frontend/handlers/bridge_handlers.go`. The `bridgeResult` struct currently has `msg` and `done` fields. We need to add a `switchCharacter bool` field. `bridgeQuit` is the model for `bridgeSwitch`. The sentinel `errSwitchCharacter` lives in `game_bridge.go` (same package). After `gameBridge` dispatches a command, it checks `result.switchCharacter` and returns the sentinel.

**Step 1: Write the failing test (TestAllCommandHandlersAreWired)**

The test already exists at `internal/frontend/handlers/game_bridge_dispatch_test.go`. Run it now — it should fail because `HandlerSwitch` is registered in `BuiltinCommands()` but not yet in `BridgeHandlers()`.

```bash
cd /home/cjohannsen/src/mud && mise run go test ./internal/frontend/handlers/... -run TestAllCommandHandlersAreWired -v 2>&1
```

Expected: FAIL — `"switch"` missing from BridgeHandlers

**Step 2: Add `switchCharacter bool` to bridgeResult**

In `internal/frontend/handlers/bridge_handlers.go`, find `bridgeResult`:

```go
type bridgeResult struct {
	msg  *gamev1.ClientMessage
	done bool
}
```

Change it to:

```go
type bridgeResult struct {
	msg             *gamev1.ClientMessage
	done            bool
	switchCharacter bool
}
```

**Step 3: Add bridgeSwitch and register it**

In `internal/frontend/handlers/bridge_handlers.go`, add `bridgeSwitch` after `bridgeQuit`:

```go
// bridgeSwitch sends a SwitchCharacterRequest and signals the command loop to return
// to the character selection screen.
//
// Precondition: bctx must be non-nil.
// Postcondition: Returns switchCharacter=true so gameBridge returns errSwitchCharacter.
func bridgeSwitch(bctx *bridgeContext) (bridgeResult, error) {
	return bridgeResult{
		msg: &gamev1.ClientMessage{
			RequestId: bctx.reqID,
			Payload:   &gamev1.ClientMessage_SwitchCharacter{SwitchCharacter: &gamev1.SwitchCharacterRequest{}},
		},
		switchCharacter: true,
	}, nil
}
```

In `BridgeHandlers()` map, add:

```go
command.HandlerSwitch: bridgeSwitch,
```

**Step 4: Add errSwitchCharacter sentinel and wire into gameBridge**

In `internal/frontend/handlers/game_bridge.go`, add near the top of the file (after imports, before `gameBridge`):

```go
// errSwitchCharacter is returned by gameBridge when the player uses the switch command.
// characterFlow checks for this sentinel to loop back to character selection.
var errSwitchCharacter = errors.New("switch character")
```

Make sure `"errors"` is in the import block.

In the `commandLoop` result handling section of `gameBridge` (where `result` is checked after `handlerFn(bctx)`), add after the existing `result.done` check:

```go
if result.switchCharacter {
	if result.msg != nil {
		if err := stream.Send(result.msg); err != nil {
			return fmt.Errorf("sending switch request: %w", err)
		}
	}
	return errSwitchCharacter
}
```

This must be placed BEFORE the general `result.msg` send so the message is sent before returning.

**Step 5: Run tests to verify TestAllCommandHandlersAreWired passes**

```bash
cd /home/cjohannsen/src/mud && mise run go test ./internal/frontend/handlers/... -run TestAllCommandHandlersAreWired -v 2>&1
```

Expected: PASS

**Step 6: Run all handler tests**

```bash
cd /home/cjohannsen/src/mud && mise run go test ./internal/frontend/handlers/... -v 2>&1 | tail -15
```

Expected: all PASS

**Step 7: Commit**

```bash
cd /home/cjohannsen/src/mud && git add internal/frontend/handlers/bridge_handlers.go internal/frontend/handlers/game_bridge.go
git commit -m "feat: add bridgeSwitch handler and errSwitchCharacter sentinel (CMD-5)"
```

---

### Task 5: Make characterFlow loop back on switch

**Files:**
- Modify: `internal/frontend/handlers/character_flow.go`
- Test: `internal/frontend/handlers/character_flow_test.go`

**Background:** Read `internal/frontend/handlers/character_flow.go`. The `characterFlow` function calls `return h.gameBridge(...)` in three places:
1. Line ~106: after forced character creation (no existing chars)
2. Line ~145: after creating a new character from the selection menu
3. Line ~151: after selecting an existing character

All three must be changed to check for `errSwitchCharacter`. Additionally, if `gameBridge` returns a "duplicate character" error (the server rejected the join because that character is already logged in), `characterFlow` must show a message and loop back instead of crashing the session.

The server rejects duplicate joins: `AddPlayer` returns `fmt.Errorf("player %q already connected", uid)` and this surfaces as a gRPC error in `gameBridge`. Check `gameBridge` to see how this error propagates — it will be wrapped, so use `strings.Contains` on the error message to detect it (since it's a gRPC status error, not a typed sentinel).

**Step 1: Write the failing tests**

In `internal/frontend/handlers/character_flow_test.go`, add:

```go
// TestCharacterFlow_SwitchLoopsBack verifies that errSwitchCharacter from gameBridge
// causes characterFlow to return to the selection loop rather than ending the session.
// This is tested indirectly via the exported sentinel — check it is defined and is an error.
func TestErrSwitchCharacter_IsError(t *testing.T) {
	if handlers.ErrSwitchCharacter == nil {
		t.Fatal("ErrSwitchCharacter must be a non-nil error")
	}
	if handlers.ErrSwitchCharacter.Error() == "" {
		t.Fatal("ErrSwitchCharacter.Error() must be non-empty")
	}
}
```

Note: export `errSwitchCharacter` as `ErrSwitchCharacter` so it can be tested from `handlers_test` package. (Update `game_bridge.go` accordingly.)

**Step 2: Run test to verify it fails**

```bash
cd /home/cjohannsen/src/mud && mise run go test ./internal/frontend/handlers/... -run TestErrSwitchCharacter -v 2>&1 | head -10
```

Expected: FAIL — `ErrSwitchCharacter` undefined (it's unexported)

**Step 3: Export errSwitchCharacter**

In `internal/frontend/handlers/game_bridge.go`, change:

```go
var errSwitchCharacter = errors.New("switch character")
```

to:

```go
// ErrSwitchCharacter is returned by gameBridge when the player uses the switch command.
// characterFlow checks for this sentinel to loop back to character selection.
var ErrSwitchCharacter = errors.New("switch character")
```

Update all internal references from `errSwitchCharacter` to `ErrSwitchCharacter`.

**Step 4: Update characterFlow to handle ErrSwitchCharacter and duplicate join**

In `internal/frontend/handlers/character_flow.go`, replace all three `return h.gameBridge(...)` call sites.

**Call site 1** (~line 106, after forced creation with no existing chars):

```go
if err := h.gameBridge(ctx, conn, acct, c); err != nil {
    if errors.Is(err, ErrSwitchCharacter) {
        continue
    }
    if isAlreadyLoggedIn(err) {
        _ = conn.WriteLine(telnet.Colorize(telnet.Red, "That character is already logged in."))
        continue
    }
    return err
}
return nil
```

**Call site 2** (~line 145, after creating a new character from menu):

```go
if err := h.gameBridge(ctx, conn, acct, c); err != nil {
    if errors.Is(err, ErrSwitchCharacter) {
        continue
    }
    if isAlreadyLoggedIn(err) {
        _ = conn.WriteLine(telnet.Colorize(telnet.Red, "That character is already logged in."))
        continue
    }
    return err
}
return nil
```

**Call site 3** (~line 151, after selecting existing character):

```go
if err := h.gameBridge(ctx, conn, acct, selected); err != nil {
    if errors.Is(err, ErrSwitchCharacter) {
        continue
    }
    if isAlreadyLoggedIn(err) {
        _ = conn.WriteLine(telnet.Colorize(telnet.Red, "That character is already logged in."))
        continue
    }
    return err
}
return nil
```

Add the helper function in `character_flow.go`:

```go
// isAlreadyLoggedIn returns true if err indicates the character is already connected.
//
// Precondition: err may be nil or non-nil.
// Postcondition: Returns true only when the error text contains "already connected".
func isAlreadyLoggedIn(err error) bool {
    return err != nil && strings.Contains(err.Error(), "already connected")
}
```

Make sure `"errors"` is imported in `character_flow.go`.

**Step 5: Run tests to verify they pass**

```bash
cd /home/cjohannsen/src/mud && mise run go test ./internal/frontend/handlers/... -v 2>&1 | tail -15
```

Expected: all PASS

**Step 6: Commit**

```bash
cd /home/cjohannsen/src/mud && git add internal/frontend/handlers/character_flow.go internal/frontend/handlers/game_bridge.go internal/frontend/handlers/character_flow_test.go
git commit -m "feat: loop back to character selection on switch (CMD-7 complete)"
```

---

### Task 6: Final build verification and deploy

**Step 1: Run full test suite**

```bash
cd /home/cjohannsen/src/mud && go list ./... | grep -v storage/postgres | xargs mise run go test -race 2>&1 | grep -E "FAIL|ok" | tail -20
```

Expected: all `ok`, no `FAIL`

**Step 2: Build all binaries**

```bash
cd /home/cjohannsen/src/mud && mise run go build ./... 2>&1
```

Expected: no output

**Step 3: Deploy**

```bash
cd /home/cjohannsen/src/mud && make docker-push
helm upgrade mud deployments/k8s/mud --values deployments/k8s/mud/values-prod.yaml --set db.user=mud --set db.password=mud --set image.tag=$(git rev-parse --short HEAD)
kubectl rollout status deployment/frontend -n mud
kubectl rollout status deployment/gameserver -n mud
```

**Step 4: Update FEATURES.md**

In `docs/requirements/FEATURES.md`, change:

```
- [ ] Switching characters without logout and disconnect
```

to:

```
- [x] Switching characters without logout and disconnect
```

**Step 5: Commit and push**

```bash
cd /home/cjohannsen/src/mud && git add docs/requirements/FEATURES.md && git commit -m "docs: mark character switching feature complete" && git push
```
